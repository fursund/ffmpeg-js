/**
 * Worker script for FFmpeg execution
 * This script runs in a Web Worker and handles all FFmpeg operations
 */
export declare const workerScript = "\n  let core = null;\n  \n  // Helper to load script - handle both blob URLs and regular URLs\n  function loadScript(url) {\n    return new Promise((resolve, reject) => {\n      try {\n        importScripts(url);\n        resolve();\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n  \n  async function loadCore(config) {\n    try {\n      // Load the core script first\n      // Try importScripts first (for classic workers)\n      try {\n        await loadScript(config.coreURL);\n      } catch (error) {\n        // If importScripts fails, try dynamic import (for module workers)\n        // Note: Dynamic import in workers may not work in all environments\n        // If this fails, we'll rely on the original error\n        throw error;\n      }\n      \n      // Verify createFFmpegCore is available\n      if (typeof createFFmpegCore === 'undefined') {\n        throw new Error('createFFmpegCore is not defined after loading core script');\n      }\n    } catch (error) {\n      throw error;\n    }\n    \n    // Determine wasmURL\n    // If not provided, derive from coreURL (as per official implementation)\n    const coreURL = config.coreURL;\n    const wasmURL = config.wasmURL || coreURL.replace(/.js$/g, '.wasm');\n    \n    // Encode wasmURL in mainScriptUrlOrBlob (as per official implementation)\n    // This is a hack to fix locateFile issue with ffmpeg-core\n    const urlConfig = {\n      wasmURL: wasmURL,\n    };\n    const encodedConfig = btoa(JSON.stringify(urlConfig));\n    const mainScriptUrlOrBlob = coreURL + '#' + encodedConfig;\n    \n    // Create the core - only pass mainScriptUrlOrBlob (as per official implementation)\n    core = await createFFmpegCore({\n      mainScriptUrlOrBlob,\n    });\n    \n    // Wait for core to be ready\n    if (core.ready && typeof core.ready.then === 'function') {\n      await core.ready;\n    }\n    \n    // Set up logger callback\n    const loggerCallback = (logObj) => {\n      const message = logObj?.message || String(logObj || '');\n      if (message && message.trim()) {\n        // Always forward log messages to main thread\n        self.postMessage({\n          type: 'log',\n          payload: { type: logObj.type || 'stdout', message },\n        });\n      }\n    };\n    \n    if (typeof core.setLogger === 'function') {\n      core.setLogger(loggerCallback);\n    } else if (core.logger !== undefined) {\n      core.logger = loggerCallback;\n    }\n    \n    // Set up progress callback\n    // Helper to validate progress values - reject obviously invalid values\n    const isValidProgress = (value) => {\n      if (typeof value !== 'number' || !isFinite(value)) return false;\n      // If it's a percentage (0-1), it should be in that range\n      if (value >= 0 && value <= 1) return true;\n      // If it's a frame number, it should be reasonable (not billions)\n      // Frame numbers typically don't exceed 10 million for reasonable videos\n      if (value > 0 && value < 10000000) return true;\n      return false;\n    };\n    \n    const progressCallback = (progressObj) => {\n      // Validate progress values before sending to main thread\n      // The FFmpeg core sometimes sends invalid/uninitialized values\n      let validProgress = null;\n      \n      if (typeof progressObj === 'number') {\n        if (isValidProgress(progressObj)) {\n          validProgress = progressObj;\n        } else {\n          return;\n        }\n      } else if (progressObj && typeof progressObj.progress === 'number') {\n        if (isValidProgress(progressObj.progress)) {\n          validProgress = progressObj.progress;\n        } else {\n          return;\n        }\n      } else if (progressObj && typeof progressObj.time === 'number') {\n        // Validate time value - should be reasonable (not MAX_SAFE_INTEGER or negative huge values)\n        if (isFinite(progressObj.time) && progressObj.time >= 0 && progressObj.time < 86400 * 365) {\n          // Time-only progress is valid, but we can't determine percentage\n          // Still forward it, but main thread will handle it appropriately\n          validProgress = progressObj;\n        } else {\n          return;\n        }\n      }\n      \n      // Only send if we have valid progress data\n      if (validProgress !== null) {\n        self.postMessage({\n          type: 'progress',\n          payload: typeof validProgress === 'number' ? validProgress : progressObj,\n        });\n      }\n    };\n    \n    if (typeof core.setProgress === 'function') {\n      core.setProgress(progressCallback);\n    } else if (core.progress !== undefined) {\n      core.progress = progressCallback;\n    }\n    \n    return core;\n  }\n  \n  let currentExecId = null;\n  let shouldTerminate = false;\n  \n  self.onmessage = async (event) => {\n    const { id, type, payload } = event.data;\n    \n    try {\n      switch (type) {\n        case 'load': {\n          await loadCore(payload);\n          self.postMessage({\n            id,\n            type: 'load',\n            success: true,\n            payload: { ready: true },\n          });\n          break;\n        }\n        \n        case 'terminate': {\n          if (currentExecId && currentExecId === payload.execId) {\n            shouldTerminate = true;\n            // Try to abort the core if available\n            if (core && typeof core.abort === 'function') {\n              try {\n                core.abort();\n              } catch (e) {\n                // Ignore errors from abort\n              }\n            }\n            self.postMessage({\n              id,\n              type: 'terminate',\n              success: true,\n            });\n          } else {\n            self.postMessage({\n              id,\n              type: 'terminate',\n              success: false,\n              error: 'No matching execution found to terminate',\n            });\n          }\n          break;\n        }\n        \n        case 'exec': {\n          if (!core) {\n            throw new Error('Core not loaded');\n          }\n          \n          // Set current exec ID and reset termination flag\n          currentExecId = payload.id || id;\n          shouldTerminate = false;\n          \n          try {\n            // Track if we see \"Aborted()\" message and progress\n            let aborted = false;\n            let progressReached100 = false;\n            const originalLogger = core.logger;\n            const originalProgress = core.progress;\n            \n            // Wrap logger to detect aborts\n            const wrappedLogger = (logObj) => {\n              if (originalLogger) {\n                originalLogger(logObj);\n              }\n              const message = logObj?.message || String(logObj || '');\n              if (message && message.trim() === 'Aborted()') {\n                aborted = true;\n              }\n            };\n            \n            // Wrap progress callback to track if we reached 100%\n            const wrappedProgress = (progressObj) => {\n              if (originalProgress) {\n                originalProgress(progressObj);\n              }\n              // Check if progress reached 100%\n              if (typeof progressObj === 'number') {\n                if (progressObj >= 1.0) {\n                  progressReached100 = true;\n                }\n              } else if (progressObj && typeof progressObj.progress === 'number') {\n                if (progressObj.progress >= 1.0) {\n                  progressReached100 = true;\n                }\n              }\n            };\n            \n            // Temporarily replace logger and progress to detect aborts and completion\n            core.logger = wrappedLogger;\n            core.progress = wrappedProgress;\n            \n            // Ensure -loglevel is set to 'info' to see frame progress messages\n            // FFmpeg by default might not output verbose logs during encoding\n            let execArgs = [...payload.args];\n            const hasLogLevel = execArgs.some((arg, idx) => \n              arg === '-loglevel' || arg === '-v' || \n              (idx > 0 && (execArgs[idx - 1] === '-loglevel' || execArgs[idx - 1] === '-v'))\n            );\n            if (!hasLogLevel) {\n              // Insert -loglevel info after the input file (usually after -i)\n              // This ensures we see frame progress messages during encoding\n              const inputIndex = execArgs.findIndex(arg => arg === '-i');\n              if (inputIndex >= 0 && inputIndex < execArgs.length - 1) {\n                execArgs.splice(inputIndex + 2, 0, '-loglevel', 'info');\n              } else {\n                // If no -i found, prepend to args\n                execArgs.unshift('-loglevel', 'info');\n              }\n            }\n            \n            // Handle timeout (if provided)\n            const timeout = payload.timeout !== undefined ? payload.timeout : -1;\n            if (typeof core.setTimeout === 'function') {\n              core.setTimeout(timeout);\n            }\n            \n            // Execute the command - in 0.12, exec() is synchronous and blocks until completion\n            // It returns the ret value directly when done\n            core.exec(...execArgs);\n            \n            // Check if termination was requested\n            if (shouldTerminate && currentExecId === (payload.id || id)) {\n              shouldTerminate = false;\n              currentExecId = null;\n              // Restore original logger and progress\n              core.logger = originalLogger;\n              core.progress = originalProgress;\n              \n              // Reset the core state\n              if (typeof core.reset === 'function') {\n                core.reset();\n              }\n              \n              // Send termination response\n              self.postMessage({\n                id,\n                type: 'exec',\n                success: false,\n                payload: { ret: -1 },\n                error: 'FFmpeg execution was terminated',\n              });\n              return;\n            }\n            \n            // Restore original logger and progress\n            core.logger = originalLogger;\n            core.progress = originalProgress;\n            \n            // Clear current exec ID\n            currentExecId = null;\n            \n            // Get the return value from core.ret\n            const ret = (core.ret !== undefined) ? core.ret : -1;\n            \n            // Reset the core state (as per official implementation)\n            if (typeof core.reset === 'function') {\n              core.reset();\n            }\n            \n            // If we saw \"Aborted()\" but progress reached 100%, that's OK (normal shutdown)\n            // Otherwise, abort is a failure\n            const abortedButComplete = aborted && progressReached100;\n            const success = (ret === 0) || abortedButComplete;\n            \n            // Send response\n            self.postMessage({\n              id,\n              type: 'exec',\n              success,\n              payload: { ret: abortedButComplete ? 0 : ret },\n              error: !success ? (aborted && !progressReached100 ? 'FFmpeg execution was aborted before completion' : 'Execution failed with exit code ' + ret) : undefined,\n            });\n          } catch (error) {\n            // Clear current exec ID on error\n            currentExecId = null;\n            shouldTerminate = false;\n            \n            // Handle execution errors\n            const errorMsg = error && error.message ? error.message : String(error);\n            self.postMessage({\n              id,\n              type: 'exec',\n              success: false,\n              payload: { ret: -1 },\n              error: errorMsg,\n            });\n          }\n          break;\n        }\n        \n        case 'writeFile': {\n          if (!core) {\n            throw new Error('Core not loaded');\n          }\n          const { path, data } = payload;\n          core.FS.writeFile(path, new Uint8Array(data));\n          self.postMessage({\n            id,\n            type: 'writeFile',\n            success: true,\n          });\n          break;\n        }\n        \n        case 'readFile': {\n          if (!core) {\n            throw new Error('Core not loaded');\n          }\n          const { path } = payload;\n          const data = core.FS.readFile(path);\n          // Convert to array for transfer\n          self.postMessage({\n            id,\n            type: 'readFile',\n            success: true,\n            payload: { data: Array.from(data) },\n          });\n          break;\n        }\n        \n        case 'deleteFile': {\n          if (!core) {\n            throw new Error('Core not loaded');\n          }\n          const { path } = payload;\n          try {\n            core.FS.unlink(path);\n            self.postMessage({\n              id,\n              type: 'deleteFile',\n              success: true,\n            });\n          } catch (error) {\n            self.postMessage({\n              id,\n              type: 'deleteFile',\n              success: false,\n              error: error?.message || String(error),\n            });\n          }\n          break;\n        }\n        \n        default:\n          self.postMessage({\n            id,\n            type: 'error',\n            success: false,\n            error: 'Unknown message type: ' + type,\n          });\n      }\n    } catch (error) {\n      self.postMessage({\n        id,\n        type,\n        success: false,\n        error: error?.message || String(error),\n      });\n    }\n  };\n";
