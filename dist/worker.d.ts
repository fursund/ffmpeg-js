/**
 * Worker script for FFmpeg execution
 * This script runs in a Web Worker and handles all FFmpeg operations
 */
export declare const workerScript = "\n  let core = null;\n  \n  // Helper to load script - handle both blob URLs and regular URLs\n  function loadScript(url) {\n    return new Promise((resolve, reject) => {\n      try {\n        importScripts(url);\n        resolve();\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n  \n  async function loadCore(config) {\n    try {\n      // Load the core script first\n      // Try importScripts first (for classic workers)\n      try {\n        await loadScript(config.coreURL);\n      } catch (error) {\n        // If importScripts fails, try dynamic import (for module workers)\n        // Note: Dynamic import in workers may not work in all environments\n        // If this fails, we'll rely on the original error\n        throw error;\n      }\n      \n      // Verify createFFmpegCore is available\n      if (typeof createFFmpegCore === 'undefined') {\n        throw new Error('createFFmpegCore is not defined after loading core script');\n      }\n    } catch (error) {\n      throw error;\n    }\n    \n    // Determine wasmURL\n    // If not provided, derive from coreURL (as per official implementation)\n    const coreURL = config.coreURL;\n    const wasmURL = config.wasmURL || coreURL.replace(/.js$/g, '.wasm');\n    \n    // Encode wasmURL in mainScriptUrlOrBlob (as per official implementation)\n    // This is a hack to fix locateFile issue with ffmpeg-core\n    const urlConfig = {\n      wasmURL: wasmURL,\n    };\n    const encodedConfig = btoa(JSON.stringify(urlConfig));\n    const mainScriptUrlOrBlob = coreURL + '#' + encodedConfig;\n    \n    // Create the core - only pass mainScriptUrlOrBlob (as per official implementation)\n    core = await createFFmpegCore({\n      mainScriptUrlOrBlob,\n    });\n    \n    // Wait for core to be ready\n    if (core.ready && typeof core.ready.then === 'function') {\n      await core.ready;\n    }\n    \n    // Set up logger callback\n    const loggerCallback = (logObj) => {\n      const message = logObj?.message || String(logObj || '');\n      if (message && message.trim()) {\n        // Always forward log messages to main thread\n        self.postMessage({\n          type: 'log',\n          payload: { type: logObj.type || 'stdout', message },\n        });\n      }\n    };\n    \n    if (typeof core.setLogger === 'function') {\n      core.setLogger(loggerCallback);\n    } else if (core.logger !== undefined) {\n      core.logger = loggerCallback;\n    }\n    \n    // Don't set up global progress callback - we only use out_time_ms from logs\n    // This ensures progress is only sent from logger parsing, not from core callbacks\n    \n    return core;\n  }\n  \n  let currentExecId = null;\n  let shouldTerminate = false;\n  \n  self.onmessage = async (event) => {\n    const { id, type, payload } = event.data;\n    \n    try {\n      switch (type) {\n        case 'load': {\n          try {\n            await loadCore(payload);\n            self.postMessage({\n              id,\n              type: 'load',\n              success: true,\n              payload: { ready: true },\n            });\n          } catch (error) {\n            self.postMessage({\n              id,\n              type: 'load',\n              success: false,\n              error: error?.message || String(error) || 'Failed to load FFmpeg core',\n            });\n          }\n          break;\n        }\n        \n        case 'terminate': {\n          if (currentExecId && currentExecId === payload.execId) {\n            shouldTerminate = true;\n            // Try to abort the core if available\n            if (core && typeof core.abort === 'function') {\n              try {\n                core.abort();\n              } catch (e) {\n                // Ignore errors from abort\n              }\n            }\n            self.postMessage({\n              id,\n              type: 'terminate',\n              success: true,\n            });\n          } else {\n            self.postMessage({\n              id,\n              type: 'terminate',\n              success: false,\n              error: 'No matching execution found to terminate',\n            });\n          }\n          break;\n        }\n        \n        case 'exec': {\n          if (!core) {\n            throw new Error('Core not loaded');\n          }\n          \n          // Set current exec ID and reset termination flag\n          currentExecId = payload.id || id;\n          shouldTerminate = false;\n          \n          try {\n            // Track if we see \"Aborted()\" message and progress\n            let aborted = false;\n            let progressReached100 = false;\n            let knownDurationSec = null;\n            let lastSize = 0; // Track last size to accumulate\n            let lastFrame = 0; // Track last frame number\n            const originalLogger = core.logger;\n            const originalProgress = core.progress;\n            \n            // Wrap logger to detect aborts and parse progress from logs\n            const wrappedLogger = (logObj) => {\n              if (originalLogger) {\n                originalLogger(logObj);\n              }\n              const message = (logObj?.message || String(logObj || '')).trim();\n              if (message === 'Aborted()') {\n                aborted = true;\n              }\n              // Parse duration once at the very beginning from ffmpeg banner\n              // This gives us totalDuration for calculating progress ratio\n              if (knownDurationSec === null && message.includes('Duration')) {\n                // Parse duration using regex - use RegExp constructor with double-escaped backslashes\n                // In template string, need \\\\ to get \\ in the string, which becomes  in the regex\n                const pattern = 'Duration:\\\\s*(\\\\d{2}):(\\\\d{2}):(\\\\d{2})\\\\.(\\\\d+)';\n                const durationRegex = new RegExp(pattern);\n                const durationMatch = message.match(durationRegex);\n                \n                if (durationMatch) {\n                  const h = parseInt(durationMatch[1], 10);\n                  const mi = parseInt(durationMatch[2], 10);\n                  const s = parseInt(durationMatch[3], 10);\n                  const frac = durationMatch[4];\n                  const fracSec = frac.length === 6 \n                    ? parseInt(frac, 10) / 1000000\n                    : parseInt(frac, 10) / 100;\n                  knownDurationSec = h * 3600 + mi * 60 + s + fracSec;\n                  self.postMessage({\n                    type: 'log',\n                    payload: { type: 'debug', message: 'DEBUG: Parsed totalDuration=' + knownDurationSec.toFixed(6) + 's (h=' + h + ', m=' + mi + ', s=' + s + ', frac=' + frac + ')' }\n                  });\n                }\n              }\n              \n              // Parse progress from log messages using out_time_ms, total_size, and frame\n              // -progress pipe:1 outputs key=value pairs, one per line\n              // Format: \"out_time_ms=4914000\", \"total_size=48\", and \"frame=78\"\n              if (knownDurationSec !== null && knownDurationSec > 0) {\n                // Parse out_time_ms\n                const timeMsRegex = new RegExp('out_time_ms\\\\s*=\\\\s*(\\\\d+)', 'i');\n                const timeMsMatch = message.match(timeMsRegex);\n                \n                // Parse total_size (in bytes)\n                const sizeRegex = new RegExp('total_size\\\\s*=\\\\s*(\\\\d+)', 'i');\n                const sizeMatch = message.match(sizeRegex);\n                \n                // Parse frame number\n                const frameRegex = new RegExp('frame\\\\s*=\\\\s*(\\\\d+)', 'i');\n                const frameMatch = message.match(frameRegex);\n                \n                if (timeMsMatch) {\n                  // out_time_ms is in microseconds, not milliseconds! Divide by 1,000,000\n                  const currentTimeSec = parseInt(timeMsMatch[1], 10) / 1000000;\n                  if (currentTimeSec >= 0 && isFinite(currentTimeSec)) {\n                    // Calculate ratio - allow it to go to 1.0 naturally\n                    const ratio = Math.max(0, Math.min(1, currentTimeSec / knownDurationSec));\n                    \n                    // Get size if available\n                    let size = null;\n                    if (sizeMatch) {\n                      size = parseInt(sizeMatch[1], 10);\n                      lastSize = size; // Update last known size\n                    } else if (lastSize > 0) {\n                      size = lastSize; // Use last known size if not in this message\n                    }\n                    \n                    // Get frame if available\n                    let frame = null;\n                    if (frameMatch) {\n                      frame = parseInt(frameMatch[1], 10);\n                      lastFrame = frame; // Update last known frame\n                    } else if (lastFrame > 0) {\n                      frame = lastFrame; // Use last known frame if not in this message\n                    }\n                    \n                    // Send progress with size and frame information\n                    const progressPayload = (size !== null || frame !== null)\n                      ? { progress: ratio, ...(size !== null && { size: size }), ...(frame !== null && { frame: frame }) }\n                      : ratio;\n                    \n                    // Debug: log progress calculation\n                    self.postMessage({\n                      type: 'log',\n                      payload: { type: 'debug', message: 'DEBUG: Progress: out_time_ms=' + timeMsMatch[1] + ' (microseconds), currentTimeSec=' + currentTimeSec.toFixed(3) + ', duration=' + knownDurationSec.toFixed(3) + ', ratio=' + ratio.toFixed(4) + (size !== null ? ', size=' + size + ' bytes' : '') + (frame !== null ? ', frame=' + frame : '') }\n                    });\n                    self.postMessage({ \n                      type: 'progress', \n                      payload: progressPayload \n                    });\n                  }\n                } else if (sizeMatch) {\n                  // Size update without time - just update lastSize for next time\n                  lastSize = parseInt(sizeMatch[1], 10);\n                } else if (frameMatch) {\n                  // Frame update without time - just update lastFrame for next time\n                  lastFrame = parseInt(frameMatch[1], 10);\n                }\n              } else if (message.includes('out_time_ms')) {\n                // Debug: out_time_ms found but duration not known yet\n                self.postMessage({\n                  type: 'log',\n                  payload: { type: 'debug', message: 'DEBUG: out_time_ms found but duration unknown (knownDurationSec=' + knownDurationSec + ')' }\n                });\n              }\n            };\n            \n            // Wrap progress callback to track if we reached 100%\n            // Note: We don't send progress from here - we use out_time_ms from logs instead\n            const wrappedProgress = (progressObj) => {\n              if (originalProgress) {\n                originalProgress(progressObj);\n              }\n              \n              // Check if progress reached 100% for completion tracking\n              if (typeof progressObj === 'number') {\n                if (progressObj >= 1.0) {\n                  progressReached100 = true;\n                }\n              } else if (progressObj && typeof progressObj.progress === 'number') {\n                if (progressObj.progress >= 1.0) {\n                  progressReached100 = true;\n                }\n              }\n              \n              // Don't send progress from here - we use out_time_ms parsing from logs instead\n              // This ensures consistent progress calculation based on time/duration\n            };\n            \n            // Temporarily replace logger and progress to detect aborts and completion\n            core.logger = wrappedLogger;\n            core.progress = wrappedProgress;\n            \n            // Ensure -loglevel is set to 'info' to see logs\n            // Also ensure -progress pipe:1 to emit time updates we can parse\n            let execArgs = [...payload.args];\n            const hasLogLevel = execArgs.some((arg, idx) => \n              arg === '-loglevel' || arg === '-v' || \n              (idx > 0 && (execArgs[idx - 1] === '-loglevel' || execArgs[idx - 1] === '-v'))\n            );\n            if (!hasLogLevel) {\n              // Insert -loglevel info after the input file (usually after -i)\n              // This ensures we see informational logs\n              const inputIndex = execArgs.findIndex(arg => arg === '-i');\n              if (inputIndex >= 0 && inputIndex < execArgs.length - 1) {\n                execArgs.splice(inputIndex + 2, 0, '-loglevel', 'info');\n              } else {\n                // If no -i found, prepend to args\n                execArgs.unshift('-loglevel', 'info');\n              }\n            }\n\n            // Add -progress pipe:1 if not provided so ffmpeg emits out_time(_ms) lines\n            const hasProgress = execArgs.some((arg, idx) => \n              arg === '-progress' || (idx > 0 && execArgs[idx - 1] === '-progress')\n            );\n            if (!hasProgress) {\n              execArgs.push('-progress', 'pipe:1');\n            }\n            \n            // Execute the command - in 0.12, exec() is synchronous and blocks until completion\n            // It returns the ret value directly when done\n            core.exec(...execArgs);\n            \n            // Check if termination was requested\n            if (shouldTerminate && currentExecId === (payload.id || id)) {\n              shouldTerminate = false;\n              currentExecId = null;\n              // Restore original logger and progress\n              core.logger = originalLogger;\n              core.progress = originalProgress;\n              \n              // Reset the core state\n              if (typeof core.reset === 'function') {\n                core.reset();\n              }\n              \n              // Send termination response\n              self.postMessage({\n                id,\n                type: 'exec',\n                success: false,\n                payload: { ret: -1 },\n                error: 'FFmpeg execution was terminated',\n              });\n              return;\n            }\n            \n            // Restore original logger and progress\n            core.logger = originalLogger;\n            core.progress = originalProgress;\n            \n            // Clear current exec ID\n            currentExecId = null;\n            \n            // Get the return value from core.ret\n            const ret = (core.ret !== undefined) ? core.ret : -1;\n            \n            // Reset the core state (as per official implementation)\n            if (typeof core.reset === 'function') {\n              core.reset();\n            }\n            \n            // If we saw \"Aborted()\" but progress reached 100%, that's OK (normal shutdown)\n            // Otherwise, abort is a failure\n            const abortedButComplete = aborted && progressReached100;\n            const success = (ret === 0) || abortedButComplete;\n            \n            // Send response\n            self.postMessage({\n              id,\n              type: 'exec',\n              success,\n              payload: { ret: abortedButComplete ? 0 : ret },\n              error: !success ? (aborted && !progressReached100 ? 'FFmpeg execution was aborted before completion' : 'Execution failed with exit code ' + ret) : undefined,\n            });\n          } catch (error) {\n            // Clear current exec ID on error\n            currentExecId = null;\n            shouldTerminate = false;\n            \n            // Handle execution errors\n            const errorMsg = error && error.message ? error.message : String(error);\n            self.postMessage({\n              id,\n              type: 'exec',\n              success: false,\n              payload: { ret: -1 },\n              error: errorMsg,\n            });\n          }\n          break;\n        }\n        \n        case 'writeFile': {\n          if (!core) {\n            throw new Error('Core not loaded');\n          }\n          const { path, data } = payload;\n          try {\n            core.FS.writeFile(path, new Uint8Array(data));\n            self.postMessage({\n              id,\n              type: 'writeFile',\n              success: true,\n            });\n          } catch (error) {\n            self.postMessage({\n              id,\n              type: 'writeFile',\n              success: false,\n              error: error?.message || String(error),\n            });\n          }\n          break;\n        }\n        \n        case 'readFile': {\n          if (!core) {\n            throw new Error('Core not loaded');\n          }\n          const { path } = payload;\n          try {\n            const data = core.FS.readFile(path);\n            // Convert to array for transfer\n            self.postMessage({\n              id,\n              type: 'readFile',\n              success: true,\n              payload: { data: Array.from(data) },\n            });\n          } catch (error) {\n            self.postMessage({\n              id,\n              type: 'readFile',\n              success: false,\n              error: error?.message || String(error) || ('Failed to read file: ' + path),\n            });\n          }\n          break;\n        }\n        \n        case 'deleteFile': {\n          if (!core) {\n            throw new Error('Core not loaded');\n          }\n          const { path } = payload;\n          try {\n            core.FS.unlink(path);\n            self.postMessage({\n              id,\n              type: 'deleteFile',\n              success: true,\n            });\n          } catch (error) {\n            self.postMessage({\n              id,\n              type: 'deleteFile',\n              success: false,\n              error: error?.message || String(error),\n            });\n          }\n          break;\n        }\n        \n        default:\n          self.postMessage({\n            id,\n            type: 'error',\n            success: false,\n            error: 'Unknown message type: ' + type,\n          });\n      }\n    } catch (error) {\n      // Always include id in error response so it can be matched to pending messages\n      self.postMessage({\n        id,\n        type: type || 'error',\n        success: false,\n        error: error?.message || String(error) || 'Unknown error occurred',\n      });\n    }\n  };\n";
